### 음식점 데이터 전처리 ###

food = pd.read_csv("C:/Users/k0707/OneDrive/바탕 화면/전주_음식점_100.csv",encoding = 'EUC_KR')
address = food['주소']
# 주소 데이터 깔끔하게 다듬기
for i in range(len(address)):
    a = address[i].split(' ')
    address[i] = " ".join(a[0:5])

!pip install geopy

####### 도로명주소 위도 경도 값으로 바꿔주기 ########
from geopy.geocoders import Nominatim
geo_local = Nominatim(user_agent='South Korea')

# 위도, 경도 반환하는 함수
def geocoding(address):
    try:
        geo = geo_local.geocode(address)
        x_y = [geo.latitude, geo.longitude]
        return x_y

    except:
        return [0,0]
    
latitude = []
longitude =[]

for i in address:
    latitude.append(geocoding(i)[0])
    longitude.append(geocoding(i)[1])
    
address_df = pd.DataFrame({'이름': food['업소명'],'주소':address,'위도':latitude,'경도':longitude})
address_df


### 관광지 지도 위에 표시 ###

#라이브러리 다운로드 
import folium
import pandas as pd
# 관광지 주소를 위경도 좌표로 변환한 파일 불러오기
jeonju_tour = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/관광지_위경도.xlsx")
jeonju_t = jeonju_tour[['장소','위도','경도']]
# 지도 만들기
latitude = jeonju_tour['위도'].mean()
longitude = jeonju_tour['경도'].mean()
ma=folium.Map(location=[latitude,longitude],zoom_start=12)
for i in jeonju_t.index :
    sub_lat = jeonju_t.loc[i,'위도']
    sub_long = jeonju_t.loc[i,'경도']
    
    folium.Marker(location = [sub_lat, sub_long],
                 icon = folium.Icon('red',icon='heart'),
                 ).add_to(ma)
ma  # 지도표시


### 전주 내 숙박시설 위치 표시 ###

# 라이브러리
import folium
import pandas as pd
# 숙박 시설에서 영업중인 곳의 주소를 위경도 좌표로 변환한 파일 불러오기
jeonju_house = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/전주_숙박_영업중.xlsx")
jeonju_h = jeonju_house[['위도','경도']]
latitude = jeonju_house['위도'].mean()
longitude = jeonju_house['경도'].mean()
# 지도 생성
ma=folium.Map(location=[latitude,longitude],zoom_start=12)
for i in jeonju_h.index :
    sub_lat = jeonju_h.loc[i,'위도']
    sub_long = jeonju_h.loc[i,'경도']
    
    folium.Marker(location = [sub_lat, sub_long],
                 icon = folium.Icon('blue',icon='star'),
                 ).add_to(ma)
ma


### 음식점 위치 표시 ###

# 라이브러리
import folium
import pandas as pd
# 전주 내 외지인 검색 top 100 음식점의 주소를 위 경도 좌표로 변환한 파일 불러오기
jeonju_food = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/전주_음식점_위경도.xlsx")
jeonju_f = jeonju_food[['위도','경도']]
latitude = jeonju_food['위도'].mean()
longitude = jeonju_food['경도'].mean()
# 지도 생성
ma=folium.Map(location=[latitude,longitude],zoom_start=12)
for i in jeonju_f.index :
    sub_lat = jeonju_f.loc[i,'위도']
    sub_long = jeonju_f.loc[i,'경도']
    
    folium.Marker(location = [sub_lat, sub_long],
                 icon = folium.Icon('pink',icon='fire'),
                 ).add_to(ma)
ma


### 숙박시설 군집화 ###
# 라이브러리 불러오기
import numpy as np
import pandas as pd
import folium
from sklearn.cluster import KMeans

#파일 찾아오기
jeonju_house_1 = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/전주숙박_위경도.xlsx")

#군집화
Y = jeonju_house_1[['위도', '경도']].values
n_clusters = 5
kmeans = KMeans(n_clusters=n_clusters, random_state=0).fit(Y)
jeonju_house_1['cluster'] = kmeans.labels_
jeonju_house_1.head()

#군집화 결과를 지도위에 표시
mean_latitude = jeonju_house_1['위도'].mean()
mean_longitude = jeonju_house_1['경도'].mean()
m = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=10)
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']
for index, row in jeonju_house_1.iterrows():
    folium.CircleMarker(
        location=[row['위도'], row['경도']],
        radius=5,
        color=colors[int(row['cluster'])],
        fill=True,
        fill_color=colors[int(row['cluster'])]
    ).add_to(m)
m


### 음식점 군집화 ###

# 라이브러리 불러오기
import numpy as np
import pandas as pd
import folium
from sklearn.cluster import KMeans

#파일 찾아오기
jeonju_food_1 = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/전주_음식점_위경도.xlsx")

#군집화
Y = jeonju_food_1[['위도', '경도']].values
n_clusters = 5
kmeans = KMeans(n_clusters=n_clusters, random_state=0).fit(Y)
jeonju_food_1['cluster'] = kmeans.labels_
jeonju_food_1.head()

#군집화 결과를 지도위에 표시
mean_latitude = jeonju_food_1['위도'].mean()
mean_longitude = jeonju_food_1['경도'].mean()
m = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=10)
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']
for index, row in jeonju_food_1.iterrows():
    folium.CircleMarker(
        location=[row['위도'], row['경도']],
        radius=5,
        color=colors[int(row['cluster'])],
        fill=True,
        fill_color=colors[int(row['cluster'])]
    ).add_to(m)
m


### 숙박시설 군집 중심 찾기 ###

# 라이브러리 불러오기
import numpy as np
import pandas as pd
import folium
from sklearn.cluster import KMeans

# 기하적 군집 중심을 찾기위한 함수 정의
def weiszfeld_algorithm(points, max_iterations=1000, tolerance=1e-6):
    median = np.mean(points, axis=0)
    for i in range(max_iterations):
        distances = np.linalg.norm(points - median, axis=1)
        if np.isclose(distances, 0).any():
            return points[np.isclose(distances, 0)]
        weights = 1.0 / distances
        new_median = np.sum(weights[:, np.newaxis] * points, axis=0) / np.sum(weights)
        if np.linalg.norm(new_median - median) < tolerance:
            return new_median
        median = new_median
    return median

# 군집 내 개체가 1개이면 군집화 안 하게 설정
n_clusters = 5
geometric_medians = []
for i in range(n_clusters) :
    cluster_points = jeonju_house_1[jeonju_house_1['cluster']==i][['위도','경도']].values
    if cluster_points.shape[0] > 1:
        geometric_median = weiszfeld_algorithm(cluster_points)
        geometric_medians.append(geometric_median)
        distances = np.linalg.norm(cluster_points - geometric_median, axis=1)
        sum_of_distances = np.sum(distances)
    
        print(f"Sum of distances for Cluster {i}: {sum_of_distances}")
    
        latitude, longitude = geometric_median
        print(f"Latitude and Longitude of the Geometric Median for Cluster {i}: ({latitude}, {longitude})")
    else:
        print(f"Cluster {i} has only one object, skipping...")


mean_latitude = jeonju_house_1['위도'].mean()
mean_longitude = jeonju_house_1['경도'].mean()
mmp = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=10)
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']


for index, row in jeonju_house_1.iterrows():
    folium.CircleMarker(
        location=[row['위도'], row['경도']],
        radius=5,
        color=colors[int(row['cluster'])],
        fill=True,
        fill_color=colors[int(row['cluster'])]
    ).add_to(mmp)


for i, coords in enumerate(geometric_medians):
    folium.Marker(
        location=coords,
        popup=f'Geometric Median of Cluster {i}',
        icon=folium.Icon(color=colors[i])
    ).add_to(mmp)


mmp


### 음식점 군집 중심 찾기 ###

# 라이브러리 불러오기
import numpy as np
import pandas as pd
import folium
from sklearn.cluster import KMeans

# 기하적 군집 중심을 찾기위한 함수 정의
def weiszfeld_algorithm(points, max_iterations=1000, tolerance=1e-6):
    median = np.mean(points, axis=0)
    for i in range(max_iterations):
        distances = np.linalg.norm(points - median, axis=1)
        if np.isclose(distances, 0).any():
            return points[np.isclose(distances, 0)]
        weights = 1.0 / distances
        new_median = np.sum(weights[:, np.newaxis] * points, axis=0) / np.sum(weights)
        if np.linalg.norm(new_median - median) < tolerance:
            return new_median
        median = new_median
    return median

# 군집 내 개체가 1개이면 군집화 안 하게 설정
n_clusters = 5
geometric_medians = []
for i in range(n_clusters) :
    cluster_points = jeonju_food_1[jeonju_food_1['cluster']==i][['위도','경도']].values
    if cluster_points.shape[0] > 1:
        geometric_median = weiszfeld_algorithm(cluster_points)
        geometric_medians.append(geometric_median)
        distances = np.linalg.norm(cluster_points - geometric_median, axis=1)
        sum_of_distances = np.sum(distances)
    
        print(f"Sum of distances for Cluster {i}: {sum_of_distances}")
    
        latitude, longitude = geometric_median
        print(f"Latitude and Longitude of the Geometric Median for Cluster {i}: ({latitude}, {longitude})")
    else:
        print(f"Cluster {i} has only one object, skipping...")


mean_latitude = jeonju_food_1['위도'].mean()
mean_longitude = jeonju_food_1['경도'].mean()
mmp = folium.Map(location=[mean_latitude, mean_longitude], zoom_start=10)
colors = ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen']


for index, row in jeonju_food_1.iterrows():
    folium.CircleMarker(
        location=[row['위도'], row['경도']],
        radius=5,
        color=colors[int(row['cluster'])],
        fill=True,
        fill_color=colors[int(row['cluster'])]
    ).add_to(mmp)


for i, coords in enumerate(geometric_medians):
    folium.Marker(
        location=coords,
        popup=f'Geometric Median of Cluster {i}',
        icon=folium.Icon(color=colors[i])
    ).add_to(mmp)


mmp


### 실제 도로를 고려한 실제 버스정류장 위치 ###

import pandas as pd
import folium
jeonju_bus = pd.read_excel("C:/Users/k0707/OneDrive/바탕 화면/정류장위치_도로고려.xlsx")
jeonju_b = jeonju_bus[['위도','경도']]
latitude = jeonju_bus['위도'].mean()
longitude = jeonju_bus['경도'].mean()


map = folium.Map(location=[jeonju_b['위도'][0], jeonju_b['경도'][0]], zoom_start=10)


for index, row in jeonju_b.iterrows():
    folium.CircleMarker(
        location=[row['위도'], row['경도']],
        radius=5,  
        color='red', 
        fill=True,
        fill_opacity=0.6
    ).add_to(map)
map


### 버스 최단경로 구하기 ###

### Nearest Neighbor Algorithm ###

# 라이브러리 
import folium
import numpy as np

# 최종 선정된 버스정류장의 위경도 좌표
coordinates = [
    (35.8146645, 127.1484079),
    (35.7998859, 127.0923654),
    (35.8546009, 127.1414109),
    (35.8124303, 127.1599803),
    (35.8300192, 127.1755955),
    (35.8487807, 127.1016654),
    (35.8605204, 127.1007421),
    (35.8721723, 127.0536104),
    (35.8474449, 127.1208169),
    (35.8258893, 127.1751299),
    (35.813535, 127.1471499),
    (35.8225967, 127.1438025),
    (35.8092752, 127.1621702),
    (35.8362909, 127.1280127),
    (35.8330014, 127.1691577),
    (35.818784, 127.1431934),
    (35.8142106, 127.1206966),
    (35.8475614, 127.1545963),
    (35.8169141, 127.144965),
    (35.8136618, 127.1018695),
    (35.8199878, 127.1208379),
    (35.8489732, 127.1606735),
    (35.8343343, 127.1290786),
    (35.8342893, 127.1331515)
]

# 두 정류장 사이의 거리 구하기
def calculate_distance(coord1, coord2):
    return np.sqrt((coord1[0] - coord2[0])**2 + (coord1[1] - coord2[1])**2)

# Nearest Neighbor Algorithm
def nearest_neighbor_algorithm(coordinates):
    unvisited = coordinates.copy()
    start = unvisited.pop(0)
    path = [start]
    current_location = start

    while unvisited:
        nearest_location = min(unvisited, key=lambda x: calculate_distance(current_location, x))
        path.append(nearest_location)
        unvisited.remove(nearest_location)
        current_location = nearest_location

    return path

# 경로 설정
path = nearest_neighbor_algorithm(coordinates)

# 지도 설정
map = folium.Map(location=[path[0][0], path[0][1]], zoom_start=12)


for coord in coordinates:
    folium.CircleMarker(
        location=coord,
        radius=5,
        color='blue',
        fill=True,
        fill_opacity=0.6
    ).add_to(map)

# 경로 지도위에 그리기
for i in range(len(path) - 1):
    folium.PolyLine([path[i], path[i + 1]], color="red", weight=2.5, opacity=1).add_to(map)

map


### 2-opt Algorithm ###

import math
import folium


def distance(a, b):
    return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)


def total_distance(tour, coordinates):
    return sum(distance(coordinates[tour[i]], coordinates[tour[i - 1]]) for i in range(len(tour)))


def two_opt(tour, coordinates):
    improved = True
    while improved:
        improved = False
        for i in range(1, len(tour) - 1):
            for j in range(i + 1, len(tour) - 1):  # 변경된 부분
                if j - i == 1:
                    continue
                # 변경된 부분: tour[j + 1]를 tour[(j + 1) % len(tour)]로 변경
                if distance(coordinates[tour[i - 1]], coordinates[tour[j]]) + distance(coordinates[tour[i]], coordinates[tour[(j + 1) % len(tour)]]) < distance(coordinates[tour[i - 1]], coordinates[tour[i]]) + distance(coordinates[tour[j]], coordinates[tour[(j + 1) % len(tour)]]):
                    tour[i:j + 1] = reversed(tour[i:j + 1])
                    improved = True
    return tour


coordinates = [
    (35.8146645, 127.1484079),
    (35.7998859, 127.0923654),
    (35.8546009, 127.1414109),
    (35.8124303, 127.1599803),
    (35.8300192, 127.1755955),
    (35.8487807, 127.1016654),
    (35.8605204, 127.1007421),
    (35.8721723, 127.0536104),
    (35.8474449, 127.1208169),
    (35.8258893, 127.1751299),
    (35.813535, 127.1471499),
    (35.8225967, 127.1438025),
    (35.8092752, 127.1621702),
    (35.8362909, 127.1280127),
    (35.8330014, 127.1691577),
    (35.818784, 127.1431934),
    (35.8142106, 127.1206966),
    (35.8475614, 127.1545963),
    (35.8169141, 127.144965),
    (35.8136618, 127.1018695),
    (35.8199878, 127.1208379),
    (35.8489732, 127.1606735),
    (35.8343343, 127.1290786),
    (35.8342893, 127.1331515)
]

initial_tour = list(range(len(coordinates))) + [0]

optimized_tour = two_opt(initial_tour, coordinates)

print("Optimized tour:", optimized_tour)


print("Total distance:", total_distance(optimized_tour, coordinates))


m = folium.Map(location=[35.8146645, 127.1484079], zoom_start=13)


for index in optimized_tour:
    folium.CircleMarker(location=coordinates[index], radius=3, color='blue').add_to(m)

folium.PolyLine([(coordinates[index][0], coordinates[index][1]) for index in optimized_tour], color='red').add_to(m)

m


### ACO Algorithm ### 

import math
import numpy as np
import folium


def distance(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)


coordinates = [
    (35.8146645, 127.1484079),
    (35.7998859, 127.0923654),
    (35.8546009, 127.1414109),
    (35.8124303, 127.1599803),
    (35.8300192, 127.1755955),
    (35.8487807, 127.1016654),
    (35.8605204, 127.1007421),
    (35.8721723, 127.0536104),
    (35.8474449, 127.1208169),
    (35.8258893, 127.1751299),
    (35.813535, 127.1471499),
    (35.8225967, 127.1438025),
    (35.8092752, 127.1621702),
    (35.8362909, 127.1280127),
    (35.8330014, 127.1691577),
    (35.818784, 127.1431934),
    (35.8142106, 127.1206966),
    (35.8475614, 127.1545963),
    (35.8169141, 127.144965),
    (35.8136618, 127.1018695),
    (35.8199878, 127.1208379),
    (35.8489732, 127.1606735),
    (35.8343343, 127.1290786),
    (35.8342893, 127.1331515)
]

n_ants = 10
n_iterations = 100
decay = 0.1
alpha = 1
beta = 1

n_cities = len(coordinates)
distances = np.array([[distance(coordinates[i], coordinates[j]) if i != j else 1e-7 for j in range(n_cities)] for i in range(n_cities)])
pheromones = np.ones((n_cities, n_cities))
eta = 1 / distances


def calculate_probability(k, city, unvisited, pheromones, eta, alpha, beta):
    total = sum(pheromones[city][l] ** alpha * eta[city][l] ** beta for l in unvisited)
    return (pheromones[city][k] ** alpha * eta[city][k] ** beta) / total


def aco_algorithm(n_ants, n_iterations, decay, alpha, beta, pheromones, eta):
    best_tour = None
    best_length = float('inf')

    for iteration in range(n_iterations):
        tours = []
        lengths = []

        for ant in range(n_ants):
            unvisited = list(range(n_cities))
            city = np.random.randint(n_cities)
            unvisited.remove(city)
            tour = [city]

            while unvisited:
                probabilities = [calculate_probability(k, city, unvisited, pheromones, eta, alpha, beta) for k in unvisited]
                k = np.random.choice(unvisited, p=probabilities)
                unvisited.remove(k)
                tour.append(k)
                city = k

            length = sum(distances[tour[i]][tour[i+1]] for i in range(len(tour)-1)) + distances[tour[-1]][tour[0]]
            tours.append(tour)
            lengths.append(length)

            if length < best_length:
                best_length = length
                best_tour = tour

        for tour, length in zip(tours, lengths):
            for i in range(len(tour) - 1):
                pheromones[tour[i]][tour[i+1]] += 1/length
            pheromones[tour[-1]][tour[0]] += 1/length

        pheromones = (1 - decay) * pheromones

    return best_tour, best_length


best_tour, best_length = aco_algorithm(n_ants, n_iterations, decay, alpha, beta, pheromones, eta)


m = folium.Map(location=[35.8146645, 127.1484079], zoom_start=13)


for index in best_tour:
    folium.CircleMarker(coordinates[index], radius=3, color='blue').add_to(m)


folium.PolyLine([(coordinates[i][0], coordinates[i][1]) for i in best_tour] + [(coordinates[best_tour[0]][0], coordinates[best_tour[0]][1])], color="red", weight=2.5, opacity=1).add_to(m)

m

### 크리스토피데스 Algorithm ###

!pip install networkx
import math
import numpy as np
import networkx as nx
import folium
from scipy.spatial import distance_matrix
from itertools import combinations


def distance(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)


coordinates = [
    (35.8146645, 127.1484079),
    (35.7998859, 127.0923654),
    (35.8546009, 127.1414109),
    (35.8124303, 127.1599803),
    (35.8300192, 127.1755955),
    (35.8487807, 127.1016654),
    (35.8605204, 127.1007421),
    (35.8721723, 127.0536104),
    (35.8474449, 127.1208169),
    (35.8258893, 127.1751299),
    (35.813535, 127.1471499),
    (35.8225967, 127.1438025),
    (35.8092752, 127.1621702),
    (35.8362909, 127.1280127),
    (35.8330014, 127.1691577),
    (35.818784, 127.1431934),
    (35.8142106, 127.1206966),
    (35.8475614, 127.1545963),
    (35.8169141, 127.144965),
    (35.8136618, 127.1018695),
    (35.8199878, 127.1208379),
    (35.8489732, 127.1606735),
    (35.8343343, 127.1290786),
    (35.8342893, 127.1331515)
]



dist_matrix = [[distance(coordinates[i], coordinates[j]) for j in range(len(coordinates))] for i in range(len(coordinates))]
dist_matrix = np.array(dist_matrix)



G = nx.Graph()
for i in range(len(coordinates)):
    for j in range(len(coordinates)):
        if i != j:
            G.add_edge(i, j, weight=dist_matrix[i][j])



T = nx.minimum_spanning_tree(G)



O = [v for v, d in T.degree() if d % 2 == 1]



M = nx.max_weight_matching(G.subgraph(O), maxcardinality=True)



T = nx.MultiGraph(T)
T.add_edges_from(M)



euler_circuit = list(nx.eulerian_circuit(T))



current_location = euler_circuit[0][0]
visited = set()
tour = [current_location]
visited.add(current_location)

for u, v in euler_circuit:
    if v not in visited:
        tour.append(v)
        visited.add(v)


m = folium.Map(location=[35.8146645, 127.1484079], zoom_start=13)


for index in tour:
    folium.CircleMarker(coordinates[index], radius=3, color='blue').add_to(m)


folium.PolyLine([(coordinates[i][0], coordinates[i][1]) for i in tour] + [(coordinates[tour[0]][0], coordinates[tour[0]][1])], color="red", weight=2.5, opacity=1).add_to(m)

m
